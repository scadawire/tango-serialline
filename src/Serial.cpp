/*----- PROTECTED REGION ID(Serial.cpp) ENABLED START -----*/
static const char *RcsId = "$Id: Serial.cpp,v 1.15 2013-04-03 09:27:29 jensmeyer Exp $";
//=============================================================================
//
// file :        Serial.cpp
//
// description : C++ source for the Serial and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               Serial are implemented in this file.
//
// project :     TANGO Device Server.
//
// $Author: jensmeyer $
//
// $Revision: 1.15 $
// $Date: 2013-04-03 09:27:29 $
//
// SVN only:
// $HeadURL:  $
//
// CVS only:
// $Source: /users/chaize/newsvn/cvsroot/Communication/SerialLine/src/Serial.cpp,v $
// $Log: not supported by cvs2svn $
// Revision 1.14  2011/09/22 06:11:43  pascal_verdier
// Problem in DevSerSetBaudrate and DevSerSetParameter fixed.
//
// Revision 1.13  2010/12/07 09:08:49  pascal_verdier
// Moved to Pogo-7 code generator.
//
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <tango.h>
#include <Serial.h>
#include <SerialClass.h>
#include <stdio.h>
#include <errno.h>

#ifdef __linux
#include <termios.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#endif

/*----- PROTECTED REGION END -----*/	//	Serial.cpp

/**
 *  Serial class description:
 *    C++ source for the SerialClass
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name              |  Method name
//================================================================
//  State                     |  Inherited (no method)
//  Status                    |  Inherited (no method)
//  DevSerWriteString         |  dev_ser_write_string
//  DevSerWriteChar           |  dev_ser_write_char
//  DevSerReadString          |  dev_ser_read_string
//  DevSerReadChar            |  dev_ser_read_char
//  WriteRead                 |  write_read
//  DevSerGetNChar            |  dev_ser_get_nchar
//  DevSerReadNChar           |  dev_ser_read_nchar
//  DevSerReadRaw             |  dev_ser_read_raw
//  DevSerReadLine            |  dev_ser_read_line
//  DevSerFlush               |  dev_ser_flush
//  DevSerSetParameter        |  dev_ser_set_parameter
//  DevSerSetTimeout          |  dev_ser_set_timeout
//  DevSerSetParity           |  dev_ser_set_parity
//  DevSerSetCharLength       |  dev_ser_set_char_length
//  DevSerSetStopbit          |  dev_ser_set_stopbit
//  DevSerSetBaudrate         |  dev_ser_set_baudrate
//  DevSerSetNewline          |  dev_ser_set_newline
//  DevSerReadRetry           |  dev_ser_read_retry
//  DevSerReadNBinData        |  dev_ser_read_nbin_data
//  DevSerWaitChar            |  dev_ser_wait_char
//  DevSerSetParameterCompat  |  dev_ser_set_parameter_compat
//  DevSerFlushCompat         |  dev_ser_flush_compat
//================================================================

//================================================================
//  Attributes managed is:
//================================================================
//================================================================

namespace Serial_ns
{
/*----- PROTECTED REGION ID(Serial::namespace_starting) ENABLED START -----*/

#ifdef WIN32
	// all methods containing WIN32 API calls
#include "SerialWin32.cpp"
#endif

#ifdef __linux
	// all methods containing Linux API calls
#include "SerialLinux.cpp"
#endif

	/*----- PROTECTED REGION END -----*/	//	Serial::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : Serial::Serial()
 *	Description : Constructors for a Tango device
 *                implementing the classSerial
 */
//--------------------------------------------------------
Serial::Serial(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(Serial::constructor_1) ENABLED START -----*/

	init_device();

	/*----- PROTECTED REGION END -----*/	//	Serial::constructor_1
}
//--------------------------------------------------------
Serial::Serial(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(Serial::constructor_2) ENABLED START -----*/

	init_device();

	/*----- PROTECTED REGION END -----*/	//	Serial::constructor_2
}
//--------------------------------------------------------
Serial::Serial(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(Serial::constructor_3) ENABLED START -----*/

	init_device();

	/*----- PROTECTED REGION END -----*/	//	Serial::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : Serial::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void Serial::delete_device()
{
	DEBUG_STREAM << "Serial::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::delete_device) ENABLED START -----*/

#ifdef WIN32
	close_handle_win32();
#endif

	/*----- PROTECTED REGION END -----*/	//	Serial::delete_device
}

//--------------------------------------------------------
/**
 *	Method      : Serial::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void Serial::init_device()
{
	DEBUG_STREAM << "Serial::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::init_device_before) ENABLED START -----*/

	Tango::DevVarLongArray argin_array;
	char tab[]="Serial::init_device(): ";


	INFO_STREAM << "Serial::Serial() create device " << device_name << endl;

	/*----- PROTECTED REGION END -----*/	//	Serial::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	
	/*----- PROTECTED REGION ID(Serial::init_device) ENABLED START -----*/
   if (simulated) {
        cout << "=========== Device " << device_name << " is simulated ==========" << endl;
        return;
    }


	DEBUG_STREAM << tab << "serialline:"   << serialline   << endl;
	DEBUG_STREAM << tab << "timeout:"      << timeout      << endl;
	DEBUG_STREAM << tab << "parity:"       << parity       << endl;
	DEBUG_STREAM << tab << "charlength:"   << charlength   << endl;
	DEBUG_STREAM << tab << "stopbits:"     << stopbits     << endl;
	DEBUG_STREAM << tab << "baudrate:"     << baudrate     << endl;
	DEBUG_STREAM << tab << "newline:"      << newline      << endl;


	// Mandatory properties
	if(serialline == "")
	{
		TangoSys_MemStream out_stream;
		out_stream << "serialline property not defined in the database" << ends;

		ERROR_STREAM << tab << out_stream.str() << endl;
		Tango::Except::throw_exception(
			(const char *)"Serial::error_resources",
			out_stream.str(),
        (const char *)tab);
	}
	serialdevice.serialline = serialline.c_str();

	// If timeout specified update the object
	if(timeout != -1)
	{
		serialdevice.timeout = timeout;
		DEBUG_STREAM << tab << "timeout set to: "
			<< serialdevice.timeout << "(mS)" << endl;
	}

	// If parity specified then convert it to an integer
	if (parity != "")
	{
		if (parity == "even")
		{
			this->serialdevice.parity = SL_EVEN;
			DEBUG_STREAM << tab << "parity set to: SL_EVEN" << endl;
		}
		else
		{
			if (parity == "odd")
			{
				this->serialdevice.parity = SL_ODD;
				DEBUG_STREAM << tab << "parity set to: SL_ODD" << endl;
			}
			else
			{
				this->serialdevice.parity = SL_NONE;
				DEBUG_STREAM << tab << "parity set to: SL_NONE" << endl;
			}
		}
	}

	// Do the same for the number of data bits
	switch(charlength)
	{
	case 5:
		this->serialdevice.charlength = SL_DATA5;
		DEBUG_STREAM << "Serial::init_device()::charlength set to: SL_DATA5" << endl;
		break;
	case 6:
		this->serialdevice.charlength = SL_DATA6;
		DEBUG_STREAM << "Serial::init_device()::charlength set to: SL_DATA6" << endl;
		break;
	case 7:
		this->serialdevice.charlength = SL_DATA7;
		DEBUG_STREAM << "Serial::init_device()::charlength set to: SL_DATA7" << endl;
		break;
	case 8:
		this->serialdevice.charlength = SL_DATA8;
		DEBUG_STREAM << "Serial::init_device()::charlength set to: SL_DATA8" << endl;
		break;
	default:
		break;
	}

	// Do the same for the number of stop bits, note 1.5 stopbits
	// are not supported via the database !
	switch(stopbits)
	{
	case 1:
		this->serialdevice.stopbits = SL_STOP1;
		DEBUG_STREAM << "Serial::init_device()::stopbits set to: SL_STOP1" << endl;
		break;
	case 2:
		this->serialdevice.stopbits = SL_STOP2;
		DEBUG_STREAM << "Serial::init_device()::stopbits set to: SL_STOP2" << endl;
		break;
	default:
		break;
	}

	// If baudrate specified update the object
	if(baudrate != -1)
	{
		serialdevice.baudrate = baudrate;
		DEBUG_STREAM << "Serial::init_device()::baudrate set to:"
			<< serialdevice.baudrate     << endl;
	}

	// If timeout specified update the object
	if(newline != -1)
	{
		serialdevice.newline = newline;
		DEBUG_STREAM << "Serial::init_device()::newline set to:"
			<< serialdevice.newline     << endl;
	}

	// Configure the serial line if there were defined in the database
	if (this->serialdevice.serialline != NULL)
	{
		// Open the serial line
    try
    {
		  open_desc();
    }
    catch(Tango::DevFailed& df)
    {
      FATAL_STREAM << "Serial::init_device -> DevFailed caught :\n" << df << std::endl;
      set_state(Tango::FAULT);
      set_status("Cannot open COM port defined in the device property.");
    }

		// Setup input serial line with device's default values
		argin_array.length(12);
		argin_array[0]        = SL_TIMEOUT;
		argin_array[1]        = this->serialdevice.timeout;

		argin_array[2]        = SL_PARITY;
		argin_array[3]        = this->serialdevice.parity;

		argin_array[4]        = SL_CHARLENGTH;
		argin_array[5]        = this->serialdevice.charlength;

		argin_array[6]        = SL_STOPBITS;
		argin_array[7]        = this->serialdevice.stopbits;

		argin_array[8]        = SL_BAUDRATE;
		argin_array[9]        = this->serialdevice.baudrate;

		argin_array[10]       = SL_NEWLINE;
		argin_array[11]       = this->serialdevice.newline;

		// now do the serial line real initialisation
		dev_ser_set_parameter(&argin_array);

	}
	else
	{
		// This can not happen because the test on serialline took place earlier
		FATAL_STREAM << "Serial::Serial():no serial line to initialise !" << endl;
	}

	/*----- PROTECTED REGION END -----*/	//	Serial::init_device
}

//--------------------------------------------------------
/**
 *	Method      : Serial::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void Serial::get_device_property()
{
	/*----- PROTECTED REGION ID(Serial::get_device_property_before) ENABLED START -----*/



	/*----- PROTECTED REGION END -----*/	//	Serial::get_device_property_before


	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("Serialline"));
	dev_prop.push_back(Tango::DbDatum("Timeout"));
	dev_prop.push_back(Tango::DbDatum("Parity"));
	dev_prop.push_back(Tango::DbDatum("Charlength"));
	dev_prop.push_back(Tango::DbDatum("Stopbits"));
	dev_prop.push_back(Tango::DbDatum("Baudrate"));
	dev_prop.push_back(Tango::DbDatum("Newline"));
	dev_prop.push_back(Tango::DbDatum("Simulated"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on SerialClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		SerialClass	*ds_class =
			(static_cast<SerialClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize Serialline from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  serialline;
		else {
			//	Try to initialize Serialline from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  serialline;
		}
		//	And try to extract Serialline value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  serialline;

		//	Try to initialize Timeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  timeout;
		else {
			//	Try to initialize Timeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  timeout;
		}
		//	And try to extract Timeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  timeout;

		//	Try to initialize Parity from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  parity;
		else {
			//	Try to initialize Parity from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  parity;
		}
		//	And try to extract Parity value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  parity;

		//	Try to initialize Charlength from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  charlength;
		else {
			//	Try to initialize Charlength from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  charlength;
		}
		//	And try to extract Charlength value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  charlength;

		//	Try to initialize Stopbits from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  stopbits;
		else {
			//	Try to initialize Stopbits from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  stopbits;
		}
		//	And try to extract Stopbits value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  stopbits;

		//	Try to initialize Baudrate from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  baudrate;
		else {
			//	Try to initialize Baudrate from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  baudrate;
		}
		//	And try to extract Baudrate value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  baudrate;

		//	Try to initialize Newline from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  newline;
		else {
			//	Try to initialize Newline from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  newline;
		}
		//	And try to extract Newline value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  newline;

		//	Try to initialize Simulated from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  simulated;
		else {
			//	Try to initialize Simulated from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  simulated;
		}
		//	And try to extract Simulated value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  simulated;

	}

	/*----- PROTECTED REGION ID(Serial::get_device_property_after) ENABLED START -----*/

	//	If device is inherited from this class, the class property is not taken in account
    //  Get Simulated class property only if not yet true.
    if (!simulated) {
        string className("Serial");
        Tango::DbData	class_prop;
        class_prop.push_back(Tango::DbDatum("Simulated"));

        Tango::Util::instance()->get_database()->get_class_property(className, class_prop);
        if (class_prop[0].is_empty()==false)
            class_prop[0] >> simulated;
    }

	/*----- PROTECTED REGION END -----*/	//	Serial::get_device_property_after
}

//--------------------------------------------------------
/**
 *	Method      : Serial::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void Serial::always_executed_hook()
{
	DEBUG_STREAM << "Serial::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::always_executed_hook) ENABLED START -----*/

	//	code always executed before all requests
	if (simulated)
		Tango::Except::throw_exception(
				"DeviceSimulated",
				"This device is simulated by another one.\nCheck device or Serial class property",
				"Serial::always_executed_hook()");
	/*----- PROTECTED REGION END -----*/	//	Serial::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : Serial::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void Serial::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "Serial::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(Serial::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	Serial::read_attr_hardware
}


//--------------------------------------------------------
/**
 *	Method      : Serial::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void Serial::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(Serial::add_dynamic_attributes) ENABLED START -----*/

	//	Add your own code to create and add dynamic attributes if any

	/*----- PROTECTED REGION END -----*/	//	Serial::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command DevSerWriteString related method
 *	Description: Write a string of characters to a serial line and return
 *               the number of characters written.
 *
 *	@param argin String to write
 *	@returns Number of characters written
 */
//--------------------------------------------------------
Tango::DevLong Serial::dev_ser_write_string(Tango::DevString argin)
{
	Tango::DevLong argout;
	DEBUG_STREAM << "Serial::DevSerWriteString()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::dev_ser_write_string) ENABLED START -----*/

	long            nchar;
	//	Add your own code to control device here

	INFO_STREAM << "Serial::DevSerWriteString() : " << argin << endl;

#ifdef __linux
	nchar = write(
        this->serialdevice.serialout,
        argin,
        strlen(argin));
#endif

#ifdef WIN32
	nchar = write_win32(argin);
#endif

//		If error writing data then warn client
	if (nchar < 0)
	{
		TangoSys_MemStream out_stream;

#ifdef __linux
		out_stream << "error writing to device, errno: " << errno;
		if(errno == ETIMEDOUT)
			out_stream << " (timeout)";
		out_stream << ends;
		cerr << out_stream.str() << endl;
#endif
#ifdef WIN32
		DWORD LastError = GetLastError();
		out_stream << "error writing to device( number :" << LastError << ")" << ends;
#endif

		ERROR_STREAM << "Serial::dev_ser_write_string(): " << out_stream.str() << endl;

		Tango::Except::throw_exception(
			(const char *)"Serial::error_write",
			out_stream.str(),
			(const char *)"Serial::dev_ser_write_string");
	}

	argout = nchar;

	/*----- PROTECTED REGION END -----*/	//	Serial::dev_ser_write_string
	return argout;
}
//--------------------------------------------------------
/**
 *	Command DevSerWriteChar related method
 *	Description: Write N characters to a seria line and return the
 *               number of characters written.
 *
 *	@param argin Characters to write
 *	@returns Number of characters written
 */
//--------------------------------------------------------
Tango::DevLong Serial::dev_ser_write_char(const Tango::DevVarCharArray *argin)
{
	Tango::DevLong argout;
	DEBUG_STREAM << "Serial::DevSerWriteChar()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::dev_ser_write_char) ENABLED START -----*/

	int            nchar;
 unsigned int   i;
 char           tab[]="Serial::dev_ser_write_char(): ";
 INFO_STREAM << tab << "entering... !" << endl;

 INFO_STREAM << tab << "char to write:";
 char tab2[]="    ";
 TangoSys_MemStream os;
 for(i=0;i<argin->length();i++)
 {
  this->serialdevice.buffer[i] = (*argin)[i];

  if ( (*argin)[i]>32 )
   os << tab2 << "'" << (*argin)[i] << "'";
  else
   os << tab2 << "' '";

  os << " 0x" << std::hex << (int)((*argin)[i]) << ends;

  INFO_STREAM << os.str() << endl;

  os.seekp(0);
  os.seekg(0);
 }

	// won't be sent to serial line, for printout only
 this->serialdevice.buffer[i]=0;
#ifdef __linux
	nchar = write(
        this->serialdevice.serialout,
        this->serialdevice.buffer,
        argin->length());
#endif

#ifdef WIN32
	nchar = write_win32_bin_char_array(argin);
#endif

	//	If error writing data then warn client
	if (nchar < 0)
	{
		TangoSys_MemStream out_stream;

#ifdef __linux
		out_stream << "error writing to device, errno: " << errno;
		if(errno == ETIMEDOUT)
			out_stream << " (timeout)";

		out_stream << ends;
#endif
#ifdef WIN32
		out_stream << "error writing to device" << ends;
#endif

		ERROR_STREAM << "Serial::dev_ser_write_char(): " << out_stream.str() << endl;

		ERROR_STREAM << tab << out_stream.str() << endl;
		Tango::Except::throw_exception(
			(const char *)"Serial::error_write",
			out_stream.str(),
			(const char *)tab);
	}

	argout = nchar;

	/*----- PROTECTED REGION END -----*/	//	Serial::dev_ser_write_char
	return argout;
}
//--------------------------------------------------------
/**
 *	Command DevSerReadString related method
 *	Description: Win32 method :
 *               Read a string of characters, the type of read is specified in the
 *               input parameter SL_RAW SL_NCHAR SL_LINE
 *
 *	@param argin type of read SL_RAW SL_NCHAR SL_LINE
 *	@returns String read
 */
//--------------------------------------------------------
Tango::DevString Serial::dev_ser_read_string(Tango::DevLong argin)
{
	Tango::DevString argout;
	DEBUG_STREAM << "Serial::DevSerReadString()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::dev_ser_read_string) ENABLED START -----*/

	long              read_type;
 long              nchar;
 long              retry;
 char              tab[]="Serial::dev_ser_read_string(): ";


	INFO_STREAM << tab << "entering... !" << endl;
	read_type = argin & 0x000f;

	switch (read_type)
	{
		case SL_RAW :
			INFO_STREAM << tab << "SL_RAW" << endl;
			argout = raw_read_string();
			break;
		case SL_NCHAR :
			nchar = argin >> 8;
			INFO_STREAM << tab << "SL_NCHAR nchar="<< nchar << endl;
			argout = nchar_read_string(nchar);
			break;
		case SL_LINE :
			INFO_STREAM << tab << "SL_LINE" << endl;
			argout = line_read_string();
			break;
		case SL_RETRY :
			retry = argin >> 8;
			INFO_STREAM << tab << "SL_RETRY" << endl;
			argout = retry_read_string(retry);
			break;


		default :
			TangoSys_MemStream out_stream;
			out_stream << "unknown type of read, must be SL_RAW, SL_NCHAR, SL_LINE"
					   << ends;

			ERROR_STREAM << tab << out_stream.str() << endl;
			Tango::Except::throw_exception(
				   (const char *)"Serial::error_argin",
				   out_stream.str(),
				   (const char *)tab);
	}

	INFO_STREAM << tab << "returning: " << argout << endl;

	/*----- PROTECTED REGION END -----*/	//	Serial::dev_ser_read_string
	return argout;
}
//--------------------------------------------------------
/**
 *	Command DevSerReadChar related method
 *	Description: Win32 method :
 *               Read an array of characters, the type of read is specified in the
 *               input parameter, it can be SL_RAW SL_NCHAR SL_LINE
 *
 *	@param argin type of read SL_RAW SL_NCHAR SL_LINE
 *	@returns Array of characters read
 */
//--------------------------------------------------------
Tango::DevVarCharArray *Serial::dev_ser_read_char(Tango::DevLong argin)
{
	Tango::DevVarCharArray *argout;
	DEBUG_STREAM << "Serial::DevSerReadChar()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::dev_ser_read_char) ENABLED START -----*/

	// SOLEIL Copy and allocation mechanism has been changed between DevString and DevVarCharArray
// and is now
//
 Tango::DevString	string_argout;
 long				read_type;
 long				nchar;
 long				retry;
 char				tab[]="Serial::dev_ser_read_char(): ";

 INFO_STREAM << tab << "entering... !" << endl;

 read_type = argin & 0x000f;


 switch (read_type)
 {
  case SL_RAW :
        INFO_STREAM << tab << "SL_RAW" << endl;
        string_argout = raw_read_string();
        break;
  case SL_NCHAR :
		nchar = argin >> 8;
        INFO_STREAM << tab << "SL_NCHAR nchar = " << nchar << endl;
        string_argout = nchar_read_string(nchar);
        break;
  case SL_LINE :
        INFO_STREAM << tab << "SL_LINE" << endl;
        string_argout = line_read_string();
        break;
  case SL_RETRY :
		retry = argin >> 8;
        INFO_STREAM << tab << "SL_RETRY retry = " << retry << endl;
        string_argout = retry_read_string(retry);
        break;
  default :
        TangoSys_MemStream out_stream;
        out_stream << "unknown type of read, must be SL_RAW, SL_NCHAR, SL_LINE, SL_RETRY"
                   << ends;

        ERROR_STREAM << tab << out_stream.str() << endl;
        Tango::Except::throw_exception(
               (const char *)"Serial::error_argin",
               out_stream.str(),
               (const char *)tab);
 }

 //
 // Convert Tango::DevString to Tango_DevVarCharArray
 //
 size_t	len = this->serialdevice.ncharread;

 CORBA::Octet* buf = Tango::DevVarCharArray::allocbuf (len);

 // memory check
 if ( !buf )
 {
	TangoSys_MemStream out_stream;
	out_stream << "Tango::DevVarCharArray::allocbuf(len) : out of memory" << ends;

	ERROR_STREAM << tab << out_stream.str() << endl;
	Tango::Except::throw_exception(
		   (const char *)"Serial::memory not allocated",
		   out_stream.str(),
		   (const char *)tab);
 }

 // now we can make the copy
 ::memcpy(buf, string_argout, len);

 // copy with constructor in release (1), so it deallocates the memory itself
 argout = new Tango::DevVarCharArray(len, len, buf, 1);

 // memory check
 if ( !argout )
 {
	TangoSys_MemStream out_stream;
	out_stream << "out of memory" << ends;

	ERROR_STREAM << tab << out_stream.str() << endl;
	Tango::Except::throw_exception(
		   (const char *)"Serial::memory not allocated",
		   out_stream.str(),
		   (const char *)tab);
 }


 // Print the read string
 INFO_STREAM << tab << this->serialdevice.ncharread << " char read" << endl;
 char tab2[]="    ";
 TangoSys_MemStream os;
 for(int i=0; i<this->serialdevice.ncharread;i++)
 {
  (*argout)[i] = (string_argout)[i];

  if((*argout)[i] > 32)
   os << tab2 << "'" << (*argout)[i] << "'";
  else
   os << tab2 << "' '";

  os << " 0x" << std::hex << (int)((*argout)[i]) << ends;

  INFO_STREAM << os.str() << endl;

  os.seekp(0);
  os.seekg(0);
 }

//- To avoid any memory leaks !
 if (string_argout)
 {
 	delete [] string_argout;
	string_argout = 0;
 }

	/*----- PROTECTED REGION END -----*/	//	Serial::dev_ser_read_char
	return argout;
}
//--------------------------------------------------------
/**
 *	Command WriteRead related method
 *	Description: This method permit to send a request to a device throw the serial line and returns the
 *               response of the device.
 *               The commands write and read don't return until they have not finished.
 *
 *	@param argin type of reading strategy(RAW,NCHAR..),command to write on the port com
 *	@returns response of the device behind the serial line
 */
//--------------------------------------------------------
Tango::DevString Serial::write_read(const Tango::DevVarLongStringArray *argin)
{
	Tango::DevString argout;
	DEBUG_STREAM << "Serial::WriteRead()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::write_read) ENABLED START -----*/
 long	read_type;
 long	nchar;
 long	retry;
 char	tab[]="Serial::write_read(): ";

 //call purge to get a "read message"  coherent with the "write message"
 // 2 = Flush the input and output buffer
 dev_ser_flush(2);

 // Write input message

 char * input_string;
 input_string = (char*) ((*argin).svalue[0]).in();

 dev_ser_write_string(input_string);

 // Reading method (SL_NCHAR, SL_LINE, SL_RETRY)
 read_type = (*argin).lvalue[0] & 0x000f;

 switch (read_type)
 {
  case SL_NCHAR :
		nchar = (*argin).lvalue[0] >> 8;
        INFO_STREAM << tab << "SL_NCHAR nchar = " << nchar << endl;
        argout = nchar_read_string(nchar);
        break;
  case SL_LINE :
        INFO_STREAM << tab << "SL_LINE" << endl;
        argout = line_read_string();
        break;
  case SL_RETRY :
		retry = (*argin).lvalue[0] >> 8;
        INFO_STREAM << tab << "SL_RETRY retry = " << retry << endl;
				argout = retry_read_string(retry);
				break;
  default :
        TangoSys_MemStream out_stream;
        out_stream << "unknown type of read, must be SL_NCHAR, SL_LINE, SL_RETRY"
                   << ends;

        ERROR_STREAM << tab << out_stream.str() << endl;
        Tango::Except::throw_exception(
               (const char *)"Serial::error_argin",
               out_stream.str(),
               (const char *)tab);
 }

	/*----- PROTECTED REGION END -----*/	//	Serial::write_read
	return argout;
}
//--------------------------------------------------------
/**
 *	Command DevSerGetNChar related method
 *	Description: Return the number of chars available in receiving buffer
 *
 *	@returns number of char available in receiving buffer
 */
//--------------------------------------------------------
Tango::DevLong Serial::dev_ser_get_nchar()
{
	Tango::DevLong argout;
	DEBUG_STREAM << "Serial::DevSerGetNChar()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::dev_ser_get_nchar) ENABLED START -----*/

 char	tab[]="Serial::dev_ser_get_nchar(): ";

	// Number of characters in the receiving buffer?
	//
#ifdef WIN32
 DWORD			cur_error;
 COMSTAT		cur_stat;
	if(ClearCommError(serialdevice.hfile, &cur_error, &cur_stat) == false)
#endif
#ifdef __linux
if (ioctl(this->serialdevice.serialin, FIONREAD, &argout) < 0)
#endif

	 {
	  TangoSys_MemStream out_stream;
	  out_stream << "error reading number of char in receiving buffer" << ends;

	  ERROR_STREAM << tab << out_stream.str() << endl;

	  Tango::Except::throw_exception(
			 (const char *)"Serial::DevSerGetNChar",
			 out_stream.str(),
			 (const char *)tab);
	 }
#ifdef WIN32
 	// cur_stat structure now contains the number of bytes available in the buffer
	argout = cur_stat.cbInQue<SL_MAXSTRING?cur_stat.cbInQue:SL_MAXSTRING;
#endif
	INFO_STREAM << tab << " nb char read =" << argout << endl;

	/*----- PROTECTED REGION END -----*/	//	Serial::dev_ser_get_nchar
	return argout;
}
//--------------------------------------------------------
/**
 *	Command DevSerReadNChar related method
 *	Description: Read a string of N characters from the serial line
 *               If there are no characters to be read returns an empty string.
 *
 *	@param argin number of the caracters to read on the serial line
 *	@returns pointer to the string read updated
 */
//--------------------------------------------------------
Tango::DevString Serial::dev_ser_read_nchar(Tango::DevLong argin)
{
	Tango::DevString argout;
	DEBUG_STREAM << "Serial::DevSerReadNChar()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::dev_ser_read_nchar) ENABLED START -----*/

	//	Add your own code to control device here
    argout = nchar_read_string(argin);

	/*----- PROTECTED REGION END -----*/	//	Serial::dev_ser_read_nchar
	return argout;
}
//--------------------------------------------------------
/**
 *	Command DevSerReadRaw related method
 *	Description: read a string from the serialline device in mode raw (no end
 *               of string expected, just empty the entire serialline receiving buffer).
 *
 *	@returns pointer to the string read updated
 */
//--------------------------------------------------------
Tango::DevString Serial::dev_ser_read_raw()
{
	Tango::DevString argout;
	DEBUG_STREAM << "Serial::DevSerReadRaw()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::dev_ser_read_raw) ENABLED START -----*/

	//	Add your own code to control device here
	argout = raw_read_string ( );

	/*----- PROTECTED REGION END -----*/	//	Serial::dev_ser_read_raw
	return argout;
}
//--------------------------------------------------------
/**
 *	Command DevSerReadLine related method
 *	Description: read a string from the serialline device in mode line (up to
 *               and including the character specified by the NewLine property
 *
 *	@returns pointer to the string read updated
 */
//--------------------------------------------------------
Tango::DevString Serial::dev_ser_read_line()
{
	Tango::DevString argout;
	DEBUG_STREAM << "Serial::DevSerReadLine()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::dev_ser_read_line) ENABLED START -----*/

	//	Add your own code to control device here
	argout = line_read_string( );

	/*----- PROTECTED REGION END -----*/	//	Serial::dev_ser_read_line
	return argout;
}
//--------------------------------------------------------
/**
 *	Command DevSerFlush related method
 *	Description: Win32 method :
 *               Flush serial line port according to argin passed.
 *
 *	@param argin flush to do 0=input 1=output 2=both
 */
//--------------------------------------------------------
void Serial::dev_ser_flush(Tango::DevLong argin)
{
	DEBUG_STREAM << "Serial::DevSerFlush()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::dev_ser_flush) ENABLED START -----*/

	char	tab[]="Serial::dev_ser_flush(): ";

 INFO_STREAM << tab << "entering... !" << endl;

 INFO_STREAM << tab << "argin: " << argin;

 // Minimum check on value passed
 if((argin != 0) && (argin != 1) && (argin != 2))
 {
  TangoSys_MemStream out_stream;
  out_stream << "invalid flush action " << argin << " (0=input 1=output 2=both)"
             << ends;

  ERROR_STREAM << tab << out_stream.str() << endl;
  Tango::Except::throw_exception(
         (const char *)"Serial::error_argin",
         out_stream.str(),
         (const char *)tab);
 }

 // Flush the input buffer
 if((argin == 0) || (argin == 2))
 {
#ifdef WIN32
		PurgeComm( serialdevice.hfile, PURGE_RXABORT | PURGE_RXCLEAR );
#endif
#ifdef __linux
		tcflush(this->serialdevice.serialin, TCIFLUSH);
#endif
 }

 // Flush the output buffer
 if((argin == 1) || (argin == 2))
 {
#ifdef WIN32
		 PurgeComm( serialdevice.hfile, PURGE_TXCLEAR | PURGE_TXABORT);

#endif
#ifdef __linux
		 tcflush(this->serialdevice.serialin, TCOFLUSH);
#endif
 }

	/*----- PROTECTED REGION END -----*/	//	Serial::dev_ser_flush
}
//--------------------------------------------------------
/**
 *	Command DevSerSetParameter related method
 *	Description: Set serial line parameters
 *
 *	@param argin device parameters in pair
 */
//--------------------------------------------------------
void Serial::dev_ser_set_parameter(const Tango::DevVarLongArray *argin)
{
	DEBUG_STREAM << "Serial::DevSerSetParameter()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::dev_ser_set_parameter) ENABLED START -----*/

#ifdef __linux
	dev_ser_set_parameter_linux(argin);
#endif

#ifdef WIN32
	dev_ser_set_parameter_win32(argin);
#endif

	/*----- PROTECTED REGION END -----*/	//	Serial::dev_ser_set_parameter
}
//--------------------------------------------------------
/**
 *	Command DevSerSetTimeout related method
 *	Description: This command sets the new timeout (in ms).
 *
 *	@param argin Value of the timeout to set
 */
//--------------------------------------------------------
void Serial::dev_ser_set_timeout(Tango::DevShort argin)
{
	DEBUG_STREAM << "Serial::DevSerSetTimeout()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::dev_ser_set_timeout) ENABLED START -----*/

	Tango::DevVarLongArray argin_array ;

	DEBUG_STREAM << "Serial::dev_ser_set_timeout(): entering... !" << endl;

	//	Add your own code to control device here

	// Setup input serial line with device's new value of timeout
	argin_array.length(2);
	argin_array[0] = SL_TIMEOUT;
	argin_array[1] = argin;
	try
	{
		// now do the serial line real initialisation
		dev_ser_set_parameter(&argin_array);
	}
	catch (Tango::DevFailed & )

	{
		ERROR_STREAM << "dev_ser_set_timeout: error setting new timeout" << endl;
			Tango::Except::throw_exception(
				(const char *)"Serial::dev_ser_set_parameter",
				(const char*) "Error setting new timeout",
				(const char *)"Serial::dev_ser_set_timeout");

	}

	/*----- PROTECTED REGION END -----*/	//	Serial::dev_ser_set_timeout
}
//--------------------------------------------------------
/**
 *	Command DevSerSetParity related method
 *	Description: Sets the new parity of the serial line.
 *               NONE 0
 *               ODD 1
 *               EVEN 3
 *
 *	@param argin The new parity to set.
 */
//--------------------------------------------------------
void Serial::dev_ser_set_parity(Tango::DevShort argin)
{
	DEBUG_STREAM << "Serial::DevSerSetParity()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::dev_ser_set_parity) ENABLED START -----*/

	Tango::DevVarLongArray argin_array;

	DEBUG_STREAM << "Serial::dev_ser_set_parity(): entering... !" << endl;

	//	Add your own code to control device here

	// Setup input serial line with device's new value of parity
	argin_array.length(2);
	argin_array[0] = SL_PARITY;
	argin_array[1] = argin;

	try
	{
		// now do the serial line real initialisation
		dev_ser_set_parameter(&argin_array);
	}
	catch (Tango::DevFailed & )

	{
		ERROR_STREAM << "dev_ser_set_parity: error setting new parity" << endl;
			Tango::Except::throw_exception(
				(const char *)"Serial::dev_ser_set_parameter",
				(const char *) "Error setting new parity",
				(const char *)"Serial::dev_ser_set_parity");
	}

	/*----- PROTECTED REGION END -----*/	//	Serial::dev_ser_set_parity
}
//--------------------------------------------------------
/**
 *	Command DevSerSetCharLength related method
 *	Description: Sets the new charlength.
 *               0 = 8 bits
 *               1 = 7 bits
 *               2 = 6 bits
 *               3 = 5 bits
 *
 *	@param argin The new charlength to set
 */
//--------------------------------------------------------
void Serial::dev_ser_set_char_length(Tango::DevShort argin)
{
	DEBUG_STREAM << "Serial::DevSerSetCharLength()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::dev_ser_set_char_length) ENABLED START -----*/

	Tango::DevVarLongArray argin_array;

	DEBUG_STREAM << "Serial::dev_ser_set_char_length(): entering... !" << endl;

	//	Add your own code to control device here

	// Setup input serial line with device's new value of charlength
	argin_array.length(2);
	argin_array[0] = SL_CHARLENGTH;
	argin_array[1] = argin;

	try
	{
		// now do the serial line real initialisation
		dev_ser_set_parameter(&argin_array);
	}
	catch (Tango::DevFailed & )

	{
		ERROR_STREAM << "dev_ser_set_charlength: error setting new charlength" << endl;
			Tango::Except::throw_exception(
				(const char *)"Serial::dev_ser_set_parameter",
				(const char*) "Error setting new charlength",
				(const char *)"Serial::dev_ser_set_char_length");

	}

	/*----- PROTECTED REGION END -----*/	//	Serial::dev_ser_set_char_length
}
//--------------------------------------------------------
/**
 *	Command DevSerSetStopbit related method
 *	Description: Sets the new stop bit.
 *               0 = none
 *               1 = one stop
 *               2 = 1.5 stop bit
 *
 *	@param argin The new stopbit to set
 */
//--------------------------------------------------------
void Serial::dev_ser_set_stopbit(Tango::DevShort argin)
{
	DEBUG_STREAM << "Serial::DevSerSetStopbit()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::dev_ser_set_stopbit) ENABLED START -----*/

	Tango::DevVarLongArray argin_array;

	DEBUG_STREAM << "Serial::dev_ser_set_stopbit(): entering... !" << endl;

	//	Add your own code to control device here

	// Setup input serial line with device's new value of stopbit
	argin_array.length(2);
	argin_array[0] = SL_STOPBITS;
	argin_array[1] = argin;

	try
	{
		// now do the serial line real initialisation
		dev_ser_set_parameter(&argin_array);
	}
	catch (Tango::DevFailed &  )

	{
		ERROR_STREAM << "dev_ser_set_stopbit: error setting new stopbit" << endl;
			Tango::Except::throw_exception(
				(const char *)"Serial::dev_ser_set_parameter",
				(const char *) "Error setting new stopbit",
				(const char *)"Serial::dev_ser_set_stopbit");

	}

	/*----- PROTECTED REGION END -----*/	//	Serial::dev_ser_set_stopbit
}
//--------------------------------------------------------
/**
 *	Command DevSerSetBaudrate related method
 *	Description: Sets the new baudrateof the serial line ( up to 4 Mega).
 *               Default is 9600.
 *
 *	@param argin The new baudrate to set
 */
//--------------------------------------------------------
void Serial::dev_ser_set_baudrate(Tango::DevULong argin)
{
	DEBUG_STREAM << "Serial::DevSerSetBaudrate()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::dev_ser_set_baudrate) ENABLED START -----*/

	Tango::DevVarLongArray argin_array;

	DEBUG_STREAM << "Serial::dev_ser_set_baudrate(): entering... !" << endl;

	//	Add your own code to control device here

	// Setup input serial line with device's new value of baudrate
	argin_array.length(2);
	argin_array[0] = SL_BAUDRATE;
	argin_array[1] = argin;

	try
	{
		// now do the serial line real initialisation
		dev_ser_set_parameter(&argin_array);
	}
	catch (Tango::DevFailed & )

	{
		ERROR_STREAM << "dev_ser_set_baudrate: error setting new baudrate" << endl;
			Tango::Except::throw_exception(
				(const char *)"Serial::dev_ser_set_parameter",
				(const char*) "Error setting new baudrate",
				(const char *)"Serial::dev_ser_set_baudrate");

	}

	/*----- PROTECTED REGION END -----*/	//	Serial::dev_ser_set_baudrate
}
//--------------------------------------------------------
/**
 *	Command DevSerSetNewline related method
 *	Description: The new ending character in hexa.
 *               Default is 0x13 (=CR
 *
 *	@param argin The new line character to set
 */
//--------------------------------------------------------
void Serial::dev_ser_set_newline(Tango::DevShort argin)
{
	DEBUG_STREAM << "Serial::DevSerSetNewline()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::dev_ser_set_newline) ENABLED START -----*/

    //  Check if simulated (could be called by a class inherited from this one)
    if (simulated)
        return;

	Tango::DevVarLongArray argin_array;

	DEBUG_STREAM << "Serial::dev_ser_set_newline(): entering... !" << endl;

	//	Add your own code to control device here

	// Setup input serial line with device's new value of newline
	argin_array.length(2);
	argin_array[0] = SL_NEWLINE;
	argin_array[1] = argin;

	try
	{
		// now do the serial line real initialisation
		dev_ser_set_parameter(&argin_array);
	}
	catch (Tango::DevFailed & )

	{
		ERROR_STREAM << "dev_ser_set_newline: error setting new newline" << endl;
			Tango::Except::throw_exception(
				(const char *)"Serial::dev_ser_set_parameter",
				(const char *) "Error setting new newline",
				(const char *)"Serial::dev_ser_set_newline");

	}

	/*----- PROTECTED REGION END -----*/	//	Serial::dev_ser_set_newline
}
//--------------------------------------------------------
/**
 *	Command DevSerReadRetry related method
 *	Description: read a string from the serialline device in mode raw (no end
 *               of string expected, just empty the entire serialline receiving buffer).
 *               If read successfull, read again "nretry" times.
 *
 *	@param argin number of reading retries
 *	@returns pointer to the string read updated
 */
//--------------------------------------------------------
Tango::DevString Serial::dev_ser_read_retry(Tango::DevLong argin)
{
	Tango::DevString argout;
	DEBUG_STREAM << "Serial::DevSerReadRetry()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::dev_ser_read_retry) ENABLED START -----*/

	//	Add your own code to control device here
    argout = retry_read_string(argin);

	/*----- PROTECTED REGION END -----*/	//	Serial::dev_ser_read_retry
	return argout;
}
//--------------------------------------------------------
/**
 *	Command DevSerReadNBinData related method
 *	Description: Read the specified number of char from the serial line.
 *               If the number of caracters is greater than caracters avaiable, this command returns
 *               all caracters avaiables.
 *               If there are no characters to be read returns an empty array.
 *
 *	@param argin nb char to read
 *	@returns array of data
 */
//--------------------------------------------------------
Tango::DevVarCharArray *Serial::dev_ser_read_nbin_data(Tango::DevLong argin)
{
	Tango::DevVarCharArray *argout;
	DEBUG_STREAM << "Serial::DevSerReadNBinData()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::dev_ser_read_nbin_data) ENABLED START -----*/

	//- get the number of chars in the buffer
	Tango::DevLong number = this->dev_ser_get_nchar();

	long n = 0;
	if(argin < number) n = argin;
	else n = number;

	//- read the number specified
	Tango::DevString str = nchar_read_string(n);

	//- copy data
	argout = new Tango::DevVarCharArray();
	argout->length(n);
	for(unsigned int i = 0; i < argout->length(); i++)
		(*argout)[i] = str[i];

	delete [] str;

	/*----- PROTECTED REGION END -----*/	//	Serial::dev_ser_read_nbin_data
	return argout;
}
//--------------------------------------------------------
/**
 *	Command DevSerWaitChar related method
 *	Description: Command blocks until a char is available or the timeout expired.
 *               If the timeout value is 0 then the command returns immediately 
 *               with the number of chars available if any or timeout error if no char available
 *
 *	@returns Number of charcters in reading buffer
 */
//--------------------------------------------------------
Tango::DevLong Serial::dev_ser_wait_char()
{
	Tango::DevLong argout;
	DEBUG_STREAM << "Serial::DevSerWaitChar()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::dev_ser_wait_char) ENABLED START -----*/
	
	//	Add your own code
    
#ifdef __linux
    argout = dev_ser_wait_char_linux();
#endif   

#ifdef WIN32
	TangoSys_MemStream out_stream;
    out_stream << "The command is not implemented for Windows!" << endl;

    ERROR_STREAM << "Serial::DevSerWaitChar() - " << out_stream.str() << endl;

    Tango::Except::throw_exception(
                (const char *)"Read Error",
                 out_stream.str(),
                (const char *)"Serial::DevSerWaitChar()");
#endif
	
	/*----- PROTECTED REGION END -----*/	//	Serial::dev_ser_wait_char
	return argout;
}
//--------------------------------------------------------
/**
 *	Command DevSerSetParameterCompat related method
 *	Description: Set serial line parameters.
 *               The command is the same as DevSerSetParameters, but takes the parameters
 *               as a short array for compatibility with the old Taco interface.
 *
 *	@param argin Device parameters in pairs as a short array
 */
//--------------------------------------------------------
void Serial::dev_ser_set_parameter_compat(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "Serial::DevSerSetParameterCompat()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::dev_ser_set_parameter_compat) ENABLED START -----*/
	
	//	Add your own code
    
    // convert short array to long array

    Tango::DevVarLongArray long_array;
    long_array.length(argin->length());

    for (unsigned int i=0; i<argin->length(); i++)
    {
        long_array[i] = (Tango::DevLong) (*argin)[i];
    }

#ifdef __linux
	dev_ser_set_parameter_linux(&long_array);
#endif

#ifdef WIN32
	dev_ser_set_parameter_win32(&long_array);
#endif
	
	/*----- PROTECTED REGION END -----*/	//	Serial::dev_ser_set_parameter_compat
}
//--------------------------------------------------------
/**
 *	Command DevSerFlushCompat related method
 *	Description: Flush the serial line port according to argin passed.
 *               The command is the same as DevSerFlush but takes the
 *               input parameter as short value for compatibility with the old Taco
 *               interface.
 *
 *	@param argin flush to do 0=input 1=output 2=both
 */
//--------------------------------------------------------
void Serial::dev_ser_flush_compat(Tango::DevShort argin)
{
	DEBUG_STREAM << "Serial::DevSerFlushCompat()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Serial::dev_ser_flush_compat) ENABLED START -----*/
	
	//	Add your own code
	
    Tango::DevLong flush_param;
    flush_param = (Tango::DevLong) argin;
    
    dev_ser_flush (flush_param);
    
	/*----- PROTECTED REGION END -----*/	//	Serial::dev_ser_flush_compat
}
//--------------------------------------------------------
/**
 *	Method      : Serial::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void Serial::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(Serial::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	Serial::add_dynamic_commands
}

/*----- PROTECTED REGION ID(Serial::namespace_ending) ENABLED START -----*/

	//	Additional Methods

	/*----- PROTECTED REGION END -----*/	//	Serial::namespace_ending
} //	namespace
